Introduction to DYNAMO
----------------------

(c) Shai Machnes et al. 2010-2011
Institute of Theoretical Physics, Ulm University, Germany
email: shai.machnes at uni-ulm.de

For the scientific background, please see http://arxiv.org/abs/1011.4874

DYNAMO is a flexible framework for quantum optimal control algorithms.

It design is interesting in two ways

    * The computation needed to solve QOC problems is broken down into many sub-modules 
      (e.g. gradient function, step-size control, etc - details below), and for
      many building blocks more than one implementation is supplied.
      Technically, "function handles" (the MATLAB "@" symbols) are used to
      make capabilities plug-and-play.

    * DYNAMO attempts to minimize calculations by way of Delayed Calculations.
      Whenever a control field is modified, DYNAMO only marks that value as changed,
      and the values calculated from it (single-slice exponents, start-to-T and 
      T-to-end propagators, etc) as stale. Only when a specific value is needed
      (such as the current fidelity), are the calculations performed. At this point
      DYNAMO attempts to perform the minimal number of matrix exponentiations and 
      multiplications to arrive at the desired result.
      See the functions invalidate_timeslots_calc_cache, recompute_timeslots_now and
      update_timeslot_controls for the nitty-gritty details.

To learn DYNAMO in-depth, we suggest the following

    * Run runme.m and run_me_dynamo_demo_01.m
    * Study their code
    * Only then read the rest of this document
    * If you have any questions, email me (details at top) - I'll be happy to help

DYNAMO makes use of a single global structure, "OC" to maintain all the computational context.
Going through the structure will give you a better idea of how DYANMO works:


The OC struct contents
======================

config    Dynamo configuration, data provenance.

    version         Dynamo version string.
    date            Date and time of the optimization run.
    task            Optimization task to run.

    Q_func          Function handle for the goal function Q and its gradient.
    gradientFunc    Function handle for the gradient of the auxiliary function g (see gradient_exact, gradient_finite_diff for examples)
    expmFunc        Function handle for computing the exponent of a matrix for gradient functions other than gradient_exact (@expm)
    calcPfromHfunc  Function handle for computing the exponent of a matrix when using gradient_exact (@calcPfromH_exact_gradient)

    FirstOrder      Configuration specific to 1st-order search methods
        step_size   Current step size (context held between calculations)
    BFGS            Configuration specific to BFGS search methods
        fminopt     Structure of options supplied to MATLAB's fminunc


system    Describes the physical system. Governing equation: \dot(X)(t) = -(A +\sum_k u_k(t) B_k) X(t)

    A               Drift operator.
    B               Cell vector of the control operators.
    X_initial       Initial system state.
    X_final         Final system state.
    norm2           Overall normalization, |X_final|^2.


seq       Control sequence.

    raw_controls    Untransformed control values, size == [num_timeslices, num_controls+1]. Last column is the tau control.
    tau             Vector containing the duration of each time slice.
    tau_deriv       d tau / d tau_raw
    control         Current value of the controls, size 
    control_deriv   d control / d control_raw


cache     This is where all the calculations are cached.
          Most fields have both a value (X) and an indicator whether this value needs to be recomputed (X_is_stale)
               
    H               Current total generator for each timeslice
    P               Propagator exp(-dt*H) for each timeslice
    U               Total forward propagator to each timeslice
    L               Total backward propagator to each timeslice

    H_is_stale      Indicator, per timeslice, of staleness of H
    P_is_stale      Same for P
    U_is_stale      Same for U
    L_is_stale      Same for L

    H_needed_now    Indicator that an up-to-date value for H should be computed right now (per timeslice)
    P_needed_now    Same for P
    U_needed_now    Same for U
    L_needed_now    Same for L

    g               Auxiliary function g := trace(X_f^\dagger * X(t_n)).
    g_is_stale      Is it still valid?


opt       Optimization data
stats     Optimization statistics




List of files / functions, sorted by role
=========================================

    Demo (main) directory
        runme                   Simple usage demo


    Dynamo directory

        Initialization
            dynamo_init            Initialize Dynamo for a system and an optimization task.
            dynamo_init_controls   Initialize the controls.
            dynamo_init_opt        Initialize the optimization module.


        Search functions - Get a subspace mask & termination conditions and perform a search within that subspace
            search_first_order     1st order search function
            search_BFGS            2nd order search function


        Meta search functions, use one or more search functions repeatedly to perform a search
                                   Input: search function handle(s), submask, stop criteria for the meta-search and the search)
            search_block_cycle     Select consecutive blocks of timeslices, and perform a search within each block
            search_Krotov          Use Block_cycle for 1-slice blocks + First_order to perform the optimization
            Two_method_crossover   Two search methods, with the termination criteria for the first deciding the cross-over point

            monitor_function       Executed once every iteration during optimization, decides if we should stop.


        Various methods to calculate the gradient of the auxiliary function g:
            gradient_exact                  Exact gradient calculations (using eigendecomposition).
            gradient_finite_diff            Gradient by finite difference method: g'(x) = (g(x+eps) - g(x))/eps (trivial and relatively slow, but a good reference point).
            gradient_first_order_aprox      Gradient by first order approximation: dP_k/d_u \approx (-B_u * dt_k) * P_k.


        Goal functions
            Q_abs                  Projective goal function and gradient.
            Q_real                 Nonprojective goal function and gradient.
	    Q_open                 Goal function and gradient for open systems.


        Caching, delaying and tracking and requesting calculations

            controls_update           Update a subset of controls, and set "stale" markers appropriately        
            g_func                    Computes the auxiliary function g := trace(X_f^\dagger * X(t_n)).
            g_setup_recalc            Returns the optimal time slice in which to compute g.

            cache_refresh             Scan the cache structure and compute what is both "stale" and "needed_now", reset staleness of recomputed elements.
            cache_invalidate          Invalidates the entire cache.
            cache_recompute           Will invalidate everything, then re-calc everything in the cache.


        Miscellaneous

            calcPfromH_expm             Calculate P from H by expm
            calcPfromH_exact_gradient   Calculate P from H when gradient_exact is used. The latter performs an eigen-decomposition, which can be used to efficiently exponentiate
            controls_get                Return the controls stored in OC.control.controls, possibly filtered by a mask.
            trace_matmul                Compute trace(A*B) efficiently
            inprod                      Hilbert-Schmidt inner product of operators (or vectors).
            plot_seq                    Plot a control sequence using superposed bars.
            plot_stats                  Plot the statistics of an optimization run.

